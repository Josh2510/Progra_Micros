/*
* Laboratorio_2.asm
*
* Creado: 12 / 02 / 2026
* Autor : Josue Eli Mata Ixcayau
* Descripción: Un contador de 4 bits con LEDS que va cambiando cada segundo, junto a un display que sirve como otro contador de 4 bits,
* cuando el numero del display coincide con el numero del contador de LEDS, se cambia de estado un quinto LED que funciona como alarma 
* para indicar que ambos llegaron a un valor igual.
*/
/****************************************/
// Encabezado (Definición de Registros, Variables y Constantes)
.include "M328PDEF.inc"     // Include definitions specific to ATMega328P
.dseg
.org    SRAM_START
//variable_name:     .byte   1   // Memory alocation for variable_name:     .byte   (byte size)

.cseg
.org 0x0000
 /****************************************/
// Configuración de la pila
LDI     R16, LOW(RAMEND)
OUT     SPL, R16
LDI     R16, HIGH(RAMEND)
OUT     SPH, R16
/****************************************/
// CREACION DE TABLA PARA DISPLAY
Numero: .db 0xC0, 0xF9, 0xA4, 0xB0, 0x99, 0x92, 0x82, 0xF8, 0x80, 0x90, 0x88, 0x83, 0xF0, 0xA1, 0x86, 0x8E
// Configuracion MCU
SETUP:
	// PRESCALER
	LDI		R16,	(1 << CLKPCE)
	STS		CLKPR,	R16				// HABILITAR CAMBIOS EN CLOCK PRINCIPAL PARA HABILITAR PRESCALER
	LDI		R16,	(1 << CLKPS2)
	STS		CLKPR,	R16				// CAMBIAR FRECUENCIA DE 16 MHz a 1MHz

	// TIMER
	LDI		R16,	(1 << CS01) | (1 << CS00) // CONFIGURANDO PRESCALER DE I/O A 64
	OUT		TCCR0B,	R16
	LDI		R16,	100				// SE GUARDA EN R16 EL VALOR DE INICIO DEL TIMER
	OUT		TCNT0,	R16				// GUARDA VALORES INICIALES DE TIMER 0 EN TCNT0

	// ENTRADAS
	LDI		R16,	0x00			
	OUT		DDRC,	R16				// PONER EN ENTRADAS LOS BITS DE PORTC
	LDI		R16,	0xFF			
	OUT		PORTC,	R16				// HABILITAR PULL UPS EN PINC

	// SALIDAS
	LDI		R16,	0xFF			
	OUT		DDRB,	R16				// PONER EN SALIDAS LOS BITS DE PORTB
	OUT		DDRD,	R16				// PONER EN SALIDAS LOS BITS DE PORTD

	LDI		R16,	0x00
	OUT		PORTB,	R16				// PONER DE VALOR INICIAL PARA PORTB 0
	
	LDI		ZL,		LOW(Numero<<1)	//	
	LDI		ZH,		HIGH(Numero<<1)	//
	LPM		R16,	Z
	OUT		PORTD,	R16				// PONER DE VALOR INICIAL PARA PORTD 0
    
	LDI		R20,	0x00			// CONTADOR PARA 100 ms
	LDI		R23,	0x00			// SEGUNDO CONTADOR
	LDI		R18,	0x00			// CONTADOR DE DISPLAY
	IN		R2,		PINC			// LEE VALORES INICIALES DE PINC
		
	// DESHABILITAR COMUNICACION SERIAL
	LDI		R16,	0x00
	STS		UCSR0B,	R16
/****************************************/
// Loop Infinito
MAIN_LOOP:
	IN		R16,	TIFR0		// LEE REGISTRO DE INTERRUPCIONES DE TIMER0
	CALL	CONTADOR
	SBRS	R16,	TOV0		// SALTA SI BIT DE OVERFLOW ESTA ENCENDIDA
    RJMP    MAIN_LOOP
	
	SBI		TIFR0,	TOV0		// REGRESA BIT DE OVERFLOW A 0, PORQUE NO SE HACE AUTOMATICAMENTE
	LDI		R16,	100			// VUELVE A CARGAR VALOR INICIAL DE TIMER
	OUT		TCNT0,	R16			// MANDA VALOR INICIAL DE TIMER
	
	INC		R20					// AUMENTA CONTADOR CADA 10 ms
	CPI		R20,	10			// COMPARA CONTADOR CON 10
	BRNE	MAIN_LOOP	
	CLR		R20					// LIMPIA CONTADOR PARA 100 ms

	INC		R23					// AUMENTA CONTADOR CADA 100 ms
	CPI		R23,	10			// COMPARAMOS CONTADOR CON 10
	BRNE	MAIN_LOOP			// PARA HACER 1 SEGUNDO
	CLR		R23					// LIMPIAMOS CONTADOR DE 1 SEGUNDO

	CALL	COMPARADOR			// LLAMA FUNCION DE CONTADOR
	OUT		PORTB,	R26			// SACA VALORES DE CONTADOR A PORTB
	RJMP	MAIN_LOOP

/****************************************/
// NON-Interrupt subroutines
AUMENTO_1:
	INC		R17					// INCREMENTA REGISTRO DE CONTADOR
	ANDI	R17,	0x0F		// ELIMINA LOS 4 BITS MAS SIGNIFICANTES
	RET

DELAY:
	LDI		R19, 255		// VALORES INICIALES
	LDI		R21, 255

LOOP_DELAY_1:
	DEC		R19				// DECREMENTA
	BRNE	LOOP_DELAY_1	// SALTA HASTA QUE SEA IGUAL A 0

LOOP_DELAY_2:
	DEC		R21
	BRNE	LOOP_DELAY_1	// SALTA A DELAY 1 OTRA VEZ
	RET

CONTADOR:
	IN		R3,		PINC		// LEER PINC
	CP		R2,		R3			// COMPARA VALORES INICIALES CON VALORES ACTUALES
	BREQ	RESULTADOS			// SI SON IGUALES ENTONCES REGRESA, SALTA HASTA QUE NO SEAN IGUALES
	CALL	DELAY
	IN		R3,		PINC		// SE VUELVE A LEER PINC
	CP		R2,		R3			// SE COMPARA VALORES OTRA VEZ PARA VER SI NO HA CAMBIADO
	BREQ	RESULTADOS

	MOV		R1,		R3			// MOVEMOS VALOR DE PINC A OTRO REGISTRO
	EOR		R1,		R2			// HACEMOS UN EXCLUSIVE OR

	SBRC	R1,		0			// SKIP IF BIT IN REGISTER IS CLEAR
	CALL	BIT_0

	SBRC	R1,		1			// SKIP IF BIT IN REGISTER IS CLEAR
	CALL	BIT_1

	MOV		R2,		R3			// GUARDAMOS VALORES NUEVOS DE PINC EN VALORES ANTIGUOS
	RET

RESULTADOS:
	LDI		ZL,		LOW(Numero<<1)	// REINICIAMOS PUNTEROS
	LDI		ZH,		HIGH(Numero<<1)	//
	ADD		ZL,		R18				// SUMAMOS A PARTE BAJA DE PUNTERO CONTADOR DE DISPLAY
	LPM		R22,	Z				// MANDAMOS VALOR DE Z A R22
	OUT		PORTD,	R22				// MOSTRAMOS EN DISPLAY EL VALOR QUE ESTA EN R22
	RET

BIT_0:
	SBRS	R3,		0			// SKIP IF BIT IN REGISTER IS SET
	CALL	DISPLAY_AUMENTO		// LLAMA A AUMENTO DE VALOR EN DISPLAY
	RET

BIT_1:
	SBRS	R3,		1			// SKIP IF BIT IN REGISTER IS SET
	CALL	DISPLAY_DISMINUCION // LLAMA A DISMINIUIR VALOR EN DISPLAY
	RET

DISPLAY_AUMENTO:
	INC		R18					// AUMENTA REGISTRO DE DISPLAY
	ANDI	R18,	0x0F		// LIMPIA VALORES MAS SIGNIFICATIVOS
	RET

DISPLAY_DISMINUCION:
	DEC		R18					// DISMINUYE REGISTRO DE DISPLAY
	ANDI	R18,	0x0F		// LIMPIA VALORES MAS SIGNIFICATIVOS
	RET

COMPARADOR:
	CP		R18,	R17			// COMPARA VALOR DE CONTADOR DE 4 BITS CON REGISTRO DE DISPLAY
	BREQ	ALARMA				// SI ES IGUAL LLAMA A FUNCION ALARMA
	CALL	AUMENTO_1			// LLAMA FUNCION DE AUMENTO DE CONTADOR DE 4 BITS

SALIDAS:
	MOV		R26,	R17			// MUEVE REGISTRO DE CONTADOR A R26
	OR		R26,	R25			// HACE OR CON REGISTRO DE ALARMA
	RET

ALARMA:
	LDI		R17,	0x00		// REINICIA CONTADOR DE 4 BITS
	SWAP	R25					// HACE SWAP EN REGISTRO DE ALARMA
	INC		R25					// INCREMENTA REGISTRO DE ALARMA
	ANDI	R25,	0x01		// LIMPIA TODOS LOS BITS QUE NO SEAN BIT0
	SWAP	R25					// VUELVE A HACER SWAP
	RJMP	SALIDAS				// SALTA A SALIDAS

/****************************************/
// Interrupt routines

/****************************************/